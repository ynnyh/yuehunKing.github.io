<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown使用指南]]></title>
    <url>%2Fcategory%2FMarkdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1. 标题标题使用英文#来进行使用，一级标题使用一个#，逐级递推。 2. 特殊符号使用方式 在句子前面使用英文(*,-,+)都可。 3. 使用代码块1hello world 使用一对1234# 4. 区块代码引用&gt; 区块引用使用```&gt;```的引用方式，区块内也可以使用markdown语法&gt;&gt; 区块引用也可以嵌套，只需根据层次加上不同数量的```&gt; 5. 列表markdown支持无序列表和有序列表无序列表使用+加号或 -减号```作为列表标记1234有序列表使用数字接着一个英文句点# 6. 分割线你可以使用以下几种方式来建立分割线 123456***# 7. 链接markdown支持两种形式的链接： 行内式和参考式两种形式。无论哪一种，链接文字都是用[方括号]来标记的要建立一个行内式的链接，只要在方括号后面紧跟圆括号并插入网址链接即可，如果要加上链接的title，只要在链接后面隔一个空格再用双引号把title文字包起来即可 this is 百度 // 效果如下12345678this is [百度](https://www.baidu.com/ &quot;百度&quot;)参考式有点费劲，不写了# 8. 强调markdown使用```*```和```_```作为标记强调字词的符号。被```*```和```_```包围的字词会被转为```&lt;em /&gt;```标签包围，用两个包围的话会转为```&lt;strong /&gt; 12345// 展示效果如下所示*em***em**_em___em__ emem_em_em]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant-design-pro踩坑记]]></title>
    <url>%2Fcategory%2Fant-design-pro%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 注册model在引入新页面时，新建model需要注册，这个时候需要在commen中的router页面进行注册，否则无法使用dispatch进行后续操作。 2.在ant-design-pro中解决跨域办法需要在配置文件中(.webpackrc)加入如下代码1234567&quot;proxy&quot;: &#123; &quot;/api&quot;: &#123; &quot;target&quot;: &quot;http://xxx:xx/&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: &#123; &quot;^/api&quot; : &quot;&quot; &#125; &#125;&#125;, 需要注意的是此处不是将/api/代理到正式请求/api/中，（例如请求/api/users则会代理到http://xxx:xx/users）如果需要多次代理且需要代理到不同的服务器则可以在配置文件中进行如下配置 123456789101112&quot;proxy&quot;: &#123; &quot;/test&quot;: &#123; &quot;target&quot;: &quot;http://xxx:xx/&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: &#123; &quot;^/test&quot; : &quot;&quot; &#125; &#125;, &quot;/cross&quot;: &#123; &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com&quot;, &quot;changeOrigin&quot;: true, &quot;pathRewrite&quot;: &#123;&quot;^/cross&quot;: &quot;&quot;&#125; &#125; // 此处有一点需要注意，不能在最后一个代理对象后面加逗号，否则会报错！！！ &#125;, 之所以不在pro中使用 /api 进行代理是因为pro中的其他接口是基于此的，所以如果对其进行代理会导致页面报错从而有可能误导开发人员。 3.权限控制在pro里面权限控制是通过Authorized来进行控制的，通过对本地存储的antd-pro-authority的值进行判断，在登陆时进行权限的刷新，所以要将权限控制精细到页面元素级别的话需要通过对获取到的值进行判断，在实际项目开发过程中，有可能该值不会存储在本地而是通过服务获取到，以此来提高安全性。 在pro中控制权限是通过角色来进行控制的，不同的角色拥有不同的权限，在 src/router 中来对角色进行权限的判定。例如登陆页面是guest，而内容页面则是admin和user。新增角色也是在此处进行添加。将权限控制精细到按钮级别，示例代码如下123456789101112import RenderAuthorized from &apos;ant-design-pro/lib/Authorized&apos;;import &#123; Alert &#125; from &apos;antd&apos;;const Authorized = RenderAuthorized(&apos;user&apos;);const noMatch = &lt;Alert message=&quot;No permission.&quot; type=&quot;error&quot; showIcon /&gt;;ReactDOM.render( &lt;Authorized authority=&#123;[&apos;user&apos;, &apos;admin&apos;]&#125; noMatch=&#123;noMatch&#125;&gt; &lt;Alert message=&quot;Use Array as a parameter passed!&quot; type=&quot;success&quot; showIcon /&gt; &lt;/Authorized&gt;, mountNode,); 需注意的是引入的是组件而不是工具类里的Authorized，两者用法不同。 4. 在model中怎么同时发起多次请求，因为yield将异步请求转为同步请求了，所以请求会按照同步顺序依次执行，使请求时间延长错误写法 123// effects将按顺序执行const response = yield call(fetch, &apos;/users&apos;);const res = yield call(fetch, &apos;/roles&apos;); 正确写法 12345// effects将会同步执行const [response, res] = yield [ call(fetch, &apos;/users&apos;), call(fetch, &apos;/roles&apos;),] 在有一些敏感数据不适合放在浏览器缓存中时，要怎么做还有一点值得考虑的是如何对权限进行分配。5. 在项目中如果需要通过类名来选择某些元素，最好直接在其属性上添加，不要使用 styles.class 这种方式，因为其在渲染后类名会发生一定的变化，导致不发通过类名来定位元素]]></content>
      <categories>
        <category>antd</category>
        <category>antd-pro</category>
        <category>dva</category>
        <category>roadhog</category>
      </categories>
      <tags>
        <tag>antd</tag>
        <tag>antd-pro</tag>
        <tag>dva</tag>
        <tag>roadhog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型]]></title>
    <url>%2Fcategory%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[关于原型的理解，可以用下面一段代码的例子来解释一二 123456789101112131415161718192021let person = &#123; getGreeting() &#123; return &apos;hello&apos;; &#125;&#125;;let dog = &#123; getGreeting() &#123; return &apos;woof&apos;; &#125;&#125;;let friend = &#123; getGreeting() &#123; return Object.getPrototypeof(this).getGreeting.call(this) + &apos;, hi!&apos;; &#125;&#125;;// 将原型设置为personObject.setPrototypeOf(friend, person);console.log(friend.getGreeting()); // &apos;hello, hi!&apos; Object.setPrototypeOf()该方法设置一个指定的对象的原型到另一个对象或null Object.setPrototypeOf(obj, prototype) 参数obj 要设置其原型的对象prototype 该对象的新原型（一个对象或null） Object.getPrototypeOf()该方法返回指定对象的原型（内部[[Prototype]]的值） Object.getProrotypeOf(object) 参数obj 要返回其原型的对象返回值 给定对象的原型，如果没有继承属性，则返回null 思路由上面代码可以知道friend的原型对象继承自person，而在调用friend.getGreeting时，此时this指向friend所以此时Object.getPrototypeOf(this)中的this指向friend，而friend的原型继承自person，所以此时即为person.getGreeting.call(this) + ‘, hi!’，此处的this依然为friend，但是在person的getGreeting中并没有只用到this的任何属性值，只是返回了一个固定值hello，所以最后结果为’hello, hi!’。]]></content>
      <categories>
        <category>JS</category>
        <category>原型</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盲点]]></title>
    <url>%2Fcategory%2Ffirst%2F</url>
    <content type="text"><![CDATA[Object.assign()该方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。12345678910const object1 = &#123; a: 1, b: 2, c: 3&#125;;const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d);// expected output: 3 5 Object.assign(target, sources)target： 目标对象source：源对象如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。 上述方法可以实现克隆且不影响源对象值，下面展示的是相反的效果12345let a = [1, 2, 3];let b = a;b.push(4);console.log(a); // 1, 2, 3, 4console.log(b); // 1, 2, 3, 4 从上面能看出来，更新数组b会同时改变数组a，因为对象和数组是引用数据类型，这意味着这样的数据类型实际上并不保存值，而是存储指向存储单元的指针。将a赋值给b，其实我们只是创建了第二个指向同一存储单元的指针。]]></content>
      <categories>
        <category>查缺补漏</category>
      </categories>
      <tags>
        <tag>查缺补漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从用户输入URL，到浏览器呈现给用户页面，经过了什么过程]]></title>
    <url>%2Fcategory%2Fquestion4%2F</url>
    <content type="text"><![CDATA[用户输入URL，浏览器获取到URL 浏览器（应用层）进行DNS解析 根据解析出的IP地址+端口，浏览器（应用层）发起HTTP请求，请求中携带（请求头header和请求体body） 请求到达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。 到网络层， 网络层通过ARP寻址得到接收方的Mac地址，IP协议把在传输层被分割成一个个数据包传送接收方。 数据到达数据链路层，请求阶段完成 接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文。 接收方收到发送方的HTTP请求之后，进行请求文件资源（如HTML页面）的寻找并响应报文 发送方收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源（如HTML文件），进行页面渲染。]]></content>
      <categories>
        <category>每日一题</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析字符串]]></title>
    <url>%2Fcategory%2Fquestion3%2F</url>
    <content type="text"><![CDATA[完成一个 extractStr 函数，可以把一个字符串中所有的 : 到 . 的子串解析出来并且存放到一个数组当中，例如：1extractStr(&apos;My name is:Jerry. My age is:12.&apos;) // =&gt; [&apos;Jerry&apos;, &apos;12&apos;] 注意，: 和 . 之间不包含 : 和 .。也即是说，如果 ::abc..，则返回 [‘abc’]。12345678const extractStr = (str) =&gt; &#123; let reg = /:([^\.:]*)\./g; let matchArr = str.match(reg) === null ? [] : str.match(reg) ; let result = matchArr.map((el) =&gt; &#123; return el.slice(1, -1); // slice从start索引值开始截取，不包含end值 &#125;); return result;&#125;]]></content>
      <categories>
        <category>每日一题</category>
        <category>正则</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[toString用法]]></title>
    <url>%2Fcategory%2Fquestion2%2F</url>
    <content type="text"><![CDATA[将给定的两个数字相加，将最后的值转为二进制，并且为字符串（可以先转换后相加也可以先相加后转换）1234function addBinary(a, b) &#123;return (a + b).toString(2);&#125;// 此处使用了Number.prototype.toString(radix)方法，其中radix指定要用于数字到字符串的转换的基数（2-36），不写则默认为10]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换指定格式]]></title>
    <url>%2Fcategory%2Fquestion1%2F</url>
    <content type="text"><![CDATA[以指定规则将指定字符串转换为指定格式如下12345678910111213141516171819202122// 将&apos;AAA&apos;转换为&apos;TTT&apos;// 将&apos;TTT&apos;转换为&apos;AAA&apos;// 将&apos;ATTGC&apos;转换为&apos;TAACG&apos;// 解法1function DNAstrand(dna)&#123; const compire = &#123; A: &apos;T&apos;, T: &apos;A&apos;, C: &apos;G&apos;, G: &apos;C&apos;, &#125;; return dna.split(&apos;&apos;).map(i =&gt; compire[i]).join(&apos;&apos;);&#125;// 解法2function DNAstrand(dna)&#123; return dna.replace(/./g, i =&gt; (&#123;A:&apos;T&apos;,C:&apos;G&apos;,G:&apos;C&apos;,T:&apos;A&apos;&#125;[i]));&#125;// 解法3function DNAstrand(dna) &#123; return dna.replace(/./g, i =&gt; &apos;ACGT&apos;[&apos;TGCA&apos;.indexOf(i)]);&#125;]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础]]></title>
    <url>%2Fcategory%2F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[emem依靠父元素的font-size来计算，1em等于父元素的font-size值，以此类推 数组1. push 接受一个或多个参数，把其传入数组的末尾，返回数组长度，改变原数组123456let a = [1, 2, 3];let res = a.push(1);console.log(res); // 输出4console.log(a); // 输出[1, 2, 3, 4];console.log(a.push(&apos;a&apos;, &apos;b&apos;)); // 输出6console.log(a); // 输出[1, 2, 3, 4, &apos;a&apos;, &apos;b&apos;]; 2. pop 移除指定数组的最后一个元素，并且返回该元素，改变原数组123456let a = [1];let res = a.pop();console.log(res); // 输出1console.log(a); // 输出[];console.log(a.pop()); // 输出undefined 数组元素为空时输出undefinedconsole.log(a); // 输出[]; 3. shift 移除指定数组的第一个元素，并且返回该元素，改变原数组12345678910// Baselet a = [5];let result = a.shift();console.log(result); // 5console.log(a); // []// Moreresult = a.shift(); // 数组元素为空后会返回undefinedconsole.log(result); // undefinedconsole.log(a); // [] 4. unshift 向指定数组的头部添加元素，并且返回该元素，改变原数组12345678910 // Baselet a = [1, 2, 3, 4, 5];let result = a.unshift(1);console.log(result); // 6console.log(a); // [1, 1, 2, 3, 4, 5]// Moreresult = a.unshift(&apos;a&apos;, &apos;b&apos;) // 可一次添加多个值console.log(result) // 8console.log(a) // [&apos;a&apos;, &apos;b&apos;, 1, 1, 2, 3, 4, 5] 5. slice(start, end)返回新数组，包含原数组索引start的值到索引end的值不包含end（不改变原数组）1234567891011let a = [1, 2, 3, 4, 5];let res = a.slice(1, 3);console.log(res); // 输出[2, 3];console.log(a); // 输出[1, 2, 3, 4, 5];// 其他情况下的例子console.log(a.slice(1)); // 只有一个参数且不小于0的情况下，则以该值作为索引start开始进行截取直到数组结束console.log(a.slice(-1)); // 只有一个参数且小于0的情况下，则以数组长度加上该值作为索引进行截取直到数组结束console.log(a.slice(-1, 1)); // 反向截取，不合法返回空数组console.log(a.slice(1, -1)); // 从start索引值开始截取到数组倒数第一位（不包含）console.log(a.slice(-1, -2)); // 反向截取，不合法返回空数组console.log(a.slice(-2, -1)); // 从数组倒数第二位截取到倒数第一位（也可以用数组长度加上负数值转为正数进行截取） 6. splice(index, count, value)从索引Index处删除count个元素，插入value（改变原数组）123456789101112131415161718192021222324252627282930// Baselet a = [1, 2, 3, 4, 5];let result = a.splice(1, 2, 0);console.log(result); // [2, 3]console.log(a); // [1, 0, 4, 5]// Morea = [1, 2, 3, 4, 5];console.log(a.splice(-2)); // [4. 5]console.log(a); // [1, 2, 3]a = [1, 2, 3, 4, 5];console.log(a.splice(-1)); // [5]console.log(a); // [1, 2, 3, 4] 当参数为单个且小于0时，将从数组的倒数|index|位截取到数组的末位a = [1, 2, 3, 4, 5];console.log(a.splice(0)); // [1, 2, 3, 4, 5]console.log(a); // []a = [1, 2, 3, 4, 5];console.log(a.splice(1)); // [2, 3, 4, 5]console.log(a); // [1] 当参数为单个且不小于0时，将从当前数代表的索引位开始截取到数组的末位a = [1, 2, 3, 4, 5];console.log(a.splice(-1, 2)); // [5]console.log(a); // [1, 2, 3, 4] 从倒数第一位开始截取两个元素，元素不够，只返回存在的元素a = [1, 2, 3, 4, 5];console.log(a.splice(0, 2, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)); // [1, 2]console.log(a); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 3, 4, 5] 截取后将value一次填充到数组被截取的位置，value的数量大于截取的数量时，数组中剩余的元素后移 7. join(value)将数组用value连接为字符串，不改变原数组123456789101112131415161718192021222324// Baselet a = [1, 2, 3, 4, 5]let result = a.join(&apos;,&apos;)console.log(result) // &apos;1,2,3,4,5&apos;console.log(a) // [1, 2, 3, 4, 5]// Morelet obj = &#123; toString() &#123; console.log(&apos;调用了toString()方法！&apos;) return &apos;a&apos; &#125;, toValue() &#123; console.log(&apos;toValue()方法！&apos;) return &apos;b&apos; &#125;&#125;result = a.join(obj) // 使用对象时会调用对象自身的toString方法转化为字符串，我们这里重写了toString，从而覆盖了原型链上的toString// 调用了toString()方法！console.log(result) // 1a2a3a4a5console.log(a) // [1, 2, 3, 4, 5]// join的一个相对的方法是字符串的split方法console.log(&apos;1a2a3a4a5&apos;.split(&apos;a&apos;)) // [1, 2, 3, 4, 5] 8. reverse()反转数组，改变原数组1234567891011121314151617181920212223242526// Baselet a = [1, 2, 3, 4, 5]let result = a.reverse()console.log(result) // [5, 4, 3, 2, 1]console.log(a) // [5, 4, 3, 2, 1]// Morea = [1, [2, 3], [4, 5]]result = a.reverse()console.log(result) // [[4, 5], [2, 3], 1]console.log(a) // [[4, 5], [2, 3], 1]// 可以看到这里的反转只是基于数组的第一层，属于浅反转。// 一个简单的深反转，使用递归实现const deepReverse = (array) =&gt; &#123; let temp = array.reverse() temp.forEach(v =&gt; &#123; if(Object.prototype.toString.call(v) === &apos;[object Array]&apos;) &#123; deepReverse(v) &#125; &#125;) return temp&#125;a = [1, [2, 3], [4, 5]]result = deepReverse(a)console.log(result) // [[5, 4], [3, 2], 1] 9. sort()对数组元素进行排序，改变原数组12345678910111213141516171819202122// Baselet a = [31, 22, 27, 1, 9]let result = a.sort()console.log(result) // [1, 22, 27, 31, 9]console.log(a) // [1, 22, 27, 31, 9]// Morea = [&apos;c&apos;, &apos;ac&apos;, &apos;ab&apos;, &apos;1c&apos;, 13, 12, &apos;13&apos;, &apos;12&apos;, &apos;3&apos;, &apos;2&apos;, &apos;1b&apos;, &apos;1a&apos;, 1, &apos;aa&apos;, &apos;a&apos;, 3, &apos;b&apos;, 2]a.sort()console.log(a) // [1, 12, &quot;12&quot;, 13, &quot;13&quot;, &quot;1a&quot;, &quot;1b&quot;, &quot;1c&quot;, &quot;2&quot;, 2, &quot;3&quot;, 3, &quot;a&quot;, &quot;aa&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;b&quot;, &quot;c&quot;] // 可以看出sort排序是根据位来进行排序，而非值的大小，先比较第一位数字在前，字母在后，若相同则比较后面位(实际是比较各个值转化为字符串后的各个位点的unicode位点)a = [31, 22, 27, 1, 9]a.sort((a, b)=&gt;&#123; return a - b&#125;)console.log(a) // [1, 9, 22, 27, 31] 按数值大小正序排列a = [31, 22, 27, 1, 9]a.sort((a, b)=&gt;&#123; return b - a&#125;)console.log(a) // [31, 27, 22, 9, 1] 按数值大小倒序排列 10. toString()将数组中的元素用逗号拼接成字符串，不改变原数组12345// Baselet a = [1, 2, 3, 4, 5]let result = a.toString()console.log(result) // 1,2,3,4,5console.log(a) // [1, 2, 3, 4, 5] 11. indexOf(value)从索引为0开始，检查数组是否包含value，有责返回匹配到的第一个索引，没有则返回-1，不改变原数组123456789// Baselet a = [1, 2, 3, 2, 5]let result = a.indexOf(2)console.log(result) // 1console.log(a) // [1, 2, 3, 2, 5]result = a.indexOf(6)console.log(result) // -1console.log(a) // [1, 2, 3, 2, 5] 12. lastIndexOf(value)从最后的索引开始，价差数组是否包含value，有则返回匹配到的第一个索引，没有则返回-1，不改变原数组123456789// Baselet a = [1, 2, 3, 2, 5]let result = a.lastIndexOf(2)console.log(result) // 3console.log(a) // [1, 2, 3, 2, 5]result = a.lastIndexOf(6)console.log(result) // -1console.log(a) // [1, 2, 3, 2, 5] 13. concat(value)将数组和value连接成新数组，不改变原数组1234567891011// Baselet a = [1, 2], b = [3, 4], c = 5let result = a.concat(b, c)console.log(result) // [1, 2, 3, 4, 5]console.log(a) // [1, 2]// Moreb = [3, [4]]result = a.concat(b, c)console.log(result) // [1, 2, 3, [4], 5] concat对于嵌套数组无法拉平console.log(a) // [1, 2] 14. fill(value, start, end)使用给定value填充数组，从索引start开始到end结束，不包含end，改变原数组12345678910111213// Baselet a = [1, 2, 3, 4, 5]let result = a.fill(0, 2, 3)console.log(result) // [1, 2, 0, 4, 5]console.log(a) // [1, 2, 0, 4, 5]// Morea = [1, 2, 3, 4, 5]console.log(a.fill(1)) // [1, 1, 1, 1, 1] 参数一个时，将该参数覆盖填充到数组每一项a = [1, 2, 3, 4, 5]console.log(a.fill(1, 2)) // [1, 2, 1, 1, 1] 只有start时，从索引start开始填充到数组末位a = [1, 2, 3, 4, 5]console.log(a.fill(1, -2)) // [1, 2, 3, 1, 1] 只有start且为负数时，从倒数|start|位开始填充到数组末位 15. flat()将二维数组变为一维数组，不改变原数组12345678910// Baselet a = [1, 2, 3, [4, 5]]let result = a.flat()console.log(result) // [1, 2, 3, 4, 5]console.log(a) // [1, 2, 3, [4, 5]]let a = [1, 2, 3, [4, 5, [6, 7, [8, 9]]]]let result = a.flat()console.log(result) // [1, 2, 3, 4, 5, [6, 7, [8, 9]]] 很显然只能将第二层嵌套数组“拉平”console.log(a) // [1, 2, 3, [4, 5, [6, 7, [8, 9]]]] 16. flatMap()相当于map与flat的结合，不改变原数组1234567// Baselet a = [1, 2, 3, 4, 5]let result = a.flatMap((currentValue)=&gt;&#123; return [currentValue, currentValue * 2]&#125;)console.log(result) // [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]console.log(a) // [1, 2, 3, 4, 5] 17. copyWithin(target, start, end)将数组从start到end索引的元素，不包含end，复制到target开始的索引位置进行替换，改变原数组123456789// Baselet a = [1, 2, 3, 4, 5]let result = a.copyWithin(0, 3, 5) console.log(result) // [4, 5, 3, 4, 5]console.log(a) // [4, 5, 3, 4, 5] 索引3到5的元素为4和5，复制到从0开始的位置，替换掉了1和2// Morea = [1, 2, 3, 4, 5]console.log(a.copyWithin(2)) // [1, 2, 1, 2, 3] 参数只有一个时，start默认为0，end默认为数组长度-1 18. entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。迭代对象中数组的索引值作为 key， 数组元素作为 value。不改变原数组123456789101112131415161718192021222324252627282930// Baselet a = [1, 2, 3, 4, 5]let result = a.entries()console.log(result.next()) // &#123;value: [0, 1], done: false&#125; value数组中第一个元素为索引，第二元素为索引对应的值...console.log(result.next()) // &#123;value: [4, 5], done: false&#125;console.log(result.next()) // &#123;value: undefined, done: true&#125;console.log(result) // Array Iterator &#123;&#125;console.log(a) // [1, 2, 3, 4, 5]result = a.entries()for(let value of result) &#123; console.log(value)&#125;// [0, 1]// [1, 2]// [2, 3]// [3, 4]// [4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()result = a.entries()for(let v of result) &#123; &#125;let dateEnd = Date.now()console.log(dateEnd - dateStart) // 运行三次，三次的耗时数 518ms 515ms 530ms 19. keys()返回一个新的Array迭代器对象，可用for…of遍历，不改变原数组1234567891011121314151617181920212223242526272829let a = [1, 2, 3, 4, 5]let result = a.keys()console.log(result.next()) // &#123;value: 0, done: false&#125; value为索引 ...console.log(result.next()) // &#123;value: 3, done: false&#125;console.log(result.next()) // &#123;value: 4, done: false&#125;console.log(result) // Array Iterator &#123;&#125;console.log(a) // [1, 2, 3, 4, 5]result = a.keys()for(let value of result) &#123; console.log(value)&#125;// 0// 1// 2// 3// 4// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()result = a.keys()for(let v of result) &#123; &#125;let dateEnd = Date.now()console.log(dateEnd - dateStart) // 运行三次，三次的耗时数 223ms 262ms 300ms 20. values()返回一个新的迭代器，不改变原数组1234567891011121314151617181920212223242526272829let a = [1, 2, 3, 4, 5]let result = a.values()console.log(result.next()) // &#123;value: 1, done: false&#125; value为索引 ...console.log(result.next()) // &#123;value: 4, done: false&#125;console.log(result.next()) // &#123;value: 5, done: false&#125;console.log(result) // Array Iterator &#123;&#125;console.log(a) // [1, 2, 3, 4, 5]result = a.values()for(let value of result) &#123; console.log(value)&#125;// 1// 2// 3// 4// 5// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()result = a.values()for(let v of result) &#123; &#125;let dateEnd = Date.now()console.log(dateEnd - dateStart) // 运行三次，三次的耗时数 254ms 270ms 273ms 21. forEach()遍历数组，不改变原数组123456789101112131415161718192021let a = [1, 2, 3, 4, 5]let result = a.forEach((v, i)=&gt;&#123; console.log(v, i) // 1 0 // 2 1 // 3 2 // 4 3 // 5 4&#125;)console.log(result) // undefinedconsole.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.forEach(v=&gt;&#123;&#125;)let dateEnd = Date.now()console.log(dateEnd - dateStart) // 运行三次，三次的耗时数 182ms 188ms 180ms 22. every(fn)判断数组中是否所有元素都满足fn函数中的条件，不改变原数组1234567891011121314151617181920212223242526let a = [1, 2, 3, 4, 5]let result = a.every((currentValue)=&gt;&#123; return currentValue &gt; 0&#125;)console.log(result) // true 显然所有元素都大于0result = a.every((currentValue)=&gt;&#123; return currentValue &gt; 1&#125;)console.log(result) // false 1并不大于1console.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.every(v=&gt; v &gt; -1 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 运行三次，三次的耗时数 176ms 200ms 186msdateStart = Date.now()a.every(v=&gt; v &gt; 8 )dateEnd = Date.now()console.log(dateEnd - dateStart) // 0ms 0ms 0ms 不超过1ms，可见every的判断是在识别到不满足的条件时，立刻停止 23. filter(fn)返回数组中符合fn函数中条件的集合，不改变原数组12345678910111213141516171819202122232425let a = [1, 2, 3, 4, 5]let result = a.filter((currentValue)=&gt;&#123; return currentValue &gt; 4&#125;)console.log(result) // [5] 只有5满足条件console.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.filter(v=&gt; v &gt; -1 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 运行三次，三次的耗时数 584ms 660ms 552ms 全部值都满足条件的情况a = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.filter(v=&gt; v &lt; 0 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 200ms 194ms 183ms 这个时候才个forEach接近，这也是与forEach本身只有遍历的功能，没有执行其他逻辑相关 24. find(fn)返回数组中第一个匹配fn函数中条件的值，没有则返回undefined，不改变原数组12345678910111213141516171819202122232425262728293031let a = [1, 2, 3, 4, 5]let result = a.find((currentValue)=&gt;&#123; return currentValue &gt; 3&#125;)console.log(result) // 4console.log(a) // [1, 2, 3, 4, 5]let result = a.find((currentValue)=&gt;&#123; return currentValue &gt; 5&#125;)console.log(result) // undefinedconsole.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.find(v=&gt; v &lt; 0 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 185ms 197ms 203ms 全部不满足的情况下，效率与forEach相当a = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.find(v=&gt; v &gt; 10 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 0ms 0ms 0ms 小于1ms，可以判断当匹配到满足条件的第一个值后，立刻停止循环，与every相当 25. findIndex(fn)返回数组中第一个匹配fn函数中的条件的值的索引，没有则返回undefined，不改变原数组12345678910111213141516171819202122232425262728293031let a = [1, 2, 3, 4, 5]let result = a.findIndex((currentValue)=&gt;&#123; return currentValue &gt; 3&#125;)console.log(result) // 3console.log(a) // [1, 2, 3, 4, 5]let result = a.findIndex((currentValue)=&gt;&#123; return currentValue &gt; 5&#125;)console.log(result) // -1console.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.findIndex(v=&gt; v &lt; 0 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 185ms 183ms 187ms 与find相当a = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.findIndex(v=&gt; v &gt; 10 )let dateEnd = Date.now()console.log(dateEnd - dateStart) // 0ms 0ms 0ms 与find相当 26. includes()返回一个布尔值，表示某个数组是否包含给定的值，不改变原数组123456789101112131415161718192021222324252627let a = [1, 2, 3, 4, 5]let result = a.includes(2)console.log(result) // trueconsole.log(a) // [1, 2, 3, 4, 5]result = a.includes(6)console.log(result) // falseconsole.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.includes(10)let dateEnd = Date.now()console.log(dateEnd - dateStart) // 0ms 0ms 0msa = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.includes(10000000-1)let dateEnd = Date.now()console.log(dateEnd - dateStart) // 22ms 18ms 27ms 性能不错 27. map(fn)以fn函数中返回值组成新的数组返回，不改变原数组12345678910111213141516let a = [1, 2, 3, 4, 5]let result = a.map((v, i)=&gt;&#123; return 9&#125;)console.log(result) // [9, 9, 9, 9, 9]console.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.map(v=&gt;1)let dateEnd = Date.now()console.log(dateEnd - dateStart) // 2158ms 2007ms 2079ms 耗时比较大 28. reduce()累计器，不改变原数组123456789101112131415161718192021222324252627282930313233343536let a = [1, 2, 3, 4, 5]let result = a.reduce((accumulator, currentValue, currentIndex, array)=&gt;&#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue // 5 1 0 [1, 2, 3, 4, 5] 第一次accumulator的值为reduce第二个参数5, currentValue为数组第一个元素 // 6 2 1 [1, 2, 3, 4, 5] 第二次accumulator的值为5加上数组a中的第一个值，即是第一次循环时return的值 // 8 3 2 [1, 2, 3, 4, 5] 同上 // 11 4 3 [1, 2, 3, 4, 5] 同上 // 15 5 4 [1, 2, 3, 4, 5] 同上&#125;, 5)console.log(result) // 20 为最终累计的和console.log(a) // [1, 2, 3, 4, 5]// 无初始值时，accumulator的初始值为数组的第一个元素，currentValue为数组第二个元素result = a.reduce((accumulator, currentValue, currentIndex, array)=&gt;&#123; console.log(accumulator, currentValue, currentIndex, array) return accumulator + currentValue // 1 2 1 [1, 2, 3, 4, 5] // 3 3 2 [1, 2, 3, 4, 5] // 6 4 3 [1, 2, 3, 4, 5] // 10 5 4 [1, 2, 3, 4, 5]&#125;)console.log(result) // 15 为最终累计的和console.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.reduce((accumulator, currentValue, currentIndex, array)=&gt;&#123; return accumulator + currentValue&#125;)let dateEnd = Date.now()console.log(dateEnd - dateStart) // 200ms 258ms 257ms 效率与forEach相差也不多，而且比forEach多个累计的功能 29. reduceRight(fn)和reduce功能一样，只是从数组末尾进行计算30. some(fn)检查数组中是否含有满足fn函数条件的值，不改变原数组123456789101112131415161718192021222324let a = [1, 2, 3, 4, 5]let result = a.some((v)=&gt;&#123; return v &gt; 2&#125;)console.log(result) // trueconsole.log(a) // [1, 2, 3, 4, 5]result = a.some((v)=&gt;&#123; return v &gt; 6&#125;)console.log(result) // falseconsole.log(a) // [1, 2, 3, 4, 5]// Timea = []for(let i = 0; i &lt; 10000000; i++) &#123; a.push(i)&#125;let dateStart = Date.now()a.some(v=&gt;&#123; return v &lt; 0&#125;)let dateEnd = Date.now()console.log(dateEnd - dateStart) // 171ms 176ms 188ms 全部不满足的情况下效率与forEach相当 31. toLocalString() 将数组中的每个元素使用各自的toLocalString()转换后用,拼接，不改变原数组1234let a = [1, new Date(), &apos;a&apos;, &#123;m: 1&#125;]let result = a.toLocaleString()console.log(result) // &apos;1,2018/10/3 下午9:23:59,a,[object Object]&apos;console.log(a) // [1, Wed Oct 03 2018 21:23:59 GMT+0800 (中国标准时间), &quot;a&quot;, &#123;m: 1&#125;]]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this、call 和 apply]]></title>
    <url>%2Fcategory%2Fthis%2F</url>
    <content type="text"><![CDATA[Js中的this总是指向一个对象，而具体指向哪一个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向大致可以分为以下4种。 作为对象的方法调用（当函数作为对象的方法被调用时，this指向该对象） 12345678const obj = &#123; a: 1, getA: () =&gt; &#123; console.log(this === obj); // true console.log(this.a === 1); // true &#125;,&#125;;obj.getA(); 作为普通函数调用当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的this总是指向全局对象。在浏览器的Js中，这个全局对象是window对象。 123window.name = &apos;globalName&apos;;const getName = () =&gt; console.log(this.name);getName(); // 输出globalName 构造器调用Js中没有类，但是可以从构造函数中创造对象，同时也提供了new运算符，使得构造器看起来更像一个类。除了宿主提供的一些内置函数，大部分Js函数都可以当做构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。 12345const myClass = () =&gt; &#123; this.name = &apos;yuehun&apos;;&#125;;const obj = new myClass();console.log(obj.name); // 输出yuehun 但当用new调用构造器时，还要注意一个问题，如果构造器显式地返回了一个object类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this。12345678const myClass = &#123; this.name = &apos;john&apos;; return &#123; name: &apos;yuehun&apos;, &#125;;&#125;;const obj = new myClass();console.log(obj.name); // 输出yuehun 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题123456const myClass = () =&gt; &#123; this.name = &apos;yuehun&apos;; return &apos;john&apos;;&#125;;const obj = new myClass();console.log(obj.name); // 输出yuehun Function.prototype.call或Function.prototype.apply调用跟普通的函数相比，用这两种方式能动态地改变传入函数的this123456789const obj1 = &#123; name: &apos;john&apos;, getName: () =&gt; this.name,&#125;;const obj2 = &#123; name: &apos;yuehun&apos;,&#125;;console.log(obj1.getName()); // 输出johnconsole.log(obj1.getName.call(obj2)); // 输出yuehun]]></content>
      <categories>
        <category>JS</category>
        <category>this指向</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则入门]]></title>
    <url>%2Fcategory%2F%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[正则表达式是用于匹配字符串中字符组合的模式。在js中正则表达式也是对象。 创建正则表达式使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下：1const regex = /abc/; 在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可以获得更好的性能。或者调用12```const regexp = new Regexp(&apos;abc&apos;); 正则表达式概述1const example = /pattern/flags; 模式（pattern）部分可以是任何简单的或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一个或多个标志（flags），泳衣标明正则表达式的行为。正则表达式支持下列三个标志： g：表示全局（global）模式，即模式将被用于所有字符串，而非在发现第一个匹配项时立即停止。 i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写。 m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项。 如果多个标志同时使用时，则写成：gmi。 () [] {} 的区别()的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如(\s+)表示连续空格的字符串。[]是定义匹配的字符串范围。比如[a-zA-Z0-9]表示字符文本要匹配英文字符和数字。{}一般用来表示匹配的长度。比如\d{3}表示匹配三个数字，\d{1,3}表示匹配1~3个数字，\d{3,}表示匹配3个以上数字。 ^与$^ 匹配一个字符串的开头，比如(^a)就是匹配以字母a开头的字符串$ 匹配一个字符串的结尾，比如(b$)就是匹配以字母b结尾的字符串^ 还有另一个作用就是取反，比如[^xyz]表示匹配的字符串不包含xyz. （小数点）匹配除换行符之外的任何单个字符注意问题： 如果^出现在[]中一般表示取反，而出现在其他地方则是匹配字符串的开头 2.^ 和 $ 配合可以有效匹配完整字符串 \d \s \w .\d 匹配一个非负整数，等价于[0-9]\s 匹配一个空白字符串\w 匹配一个英文字母或数字，等价于[0-9a-zA-Z]. 匹配除换行符以外的任意字符，等价于[^\n] ? + * 用 表示匹配前面元素0次或多次，比如(\s)就是匹配0个或多个空格 用 + 表示匹配前面元素1次或多次，比如(\d+)就是匹配由至少一个整数组成的字符串 用 ? 表示匹配前面元素0次或一次，相当于{0,1}，比如(\w?)就是匹配最多由一个字母或数字组成的字符串 $1与\1$1-$9存放着正则表达式中最近的9个正则表达式提取的结果，这些结果按照子匹配的出现顺序依次排列。基本语法是RegExp.$n，这些属性是静态的，除了replace中的第二个参数可以省略RegExp之外，其他地方都要使用RegExp。123456789// 使用RegExp访问/(\d+)-(\d+)-(\d+)/.test(&quot;2018-02-01&quot;);RegExp.$1 // 2018RegExp.$2 //02RegExp.$3 //01// 在replace中使用&quot;2018-02-01&quot;.replace(/(\d+)-(\d+)-(\d+)/,&quot;$1年$2月$3日&quot;);// 2018年02月03日 \1表示后向引用，是指在正则表达式中从左往右数，第一个()中的内容，以此类推，\2表示第二个()，\0表示整个表达式123456// 匹配日期格式，表达式中的\1代表重复(\-|\/|.)const rgx = /\d&#123;4&#125;(\-|\/|.)\d&#123;1,2&#125;\1\d&#123;1,2&#125;/rgx.test(&quot;2018-02-01&quot;); // truergx.test(&quot;2018-02.01&quot;); // falsergx.test(&quot;2018/02/01&quot;); // truergx.test(&quot;2018.02.01&quot;); // true 两者的区别是：\n只能用在表达式之中，而$n只能用在表达式之外的地方。 test与matchtest是用来检测字符串是否匹配某一个正则表达式，如果匹配就返回true，反之则返回false。match是获取正则表达式匹配到的结果，以数组的形式返回。 replace 本身是js字符串对象的一个方法，它允许接受两个参数：1replace([RegExp|String],[String|Function]) 第一个参数可以是一个普通的字符串或是一个正则表达式第二个参数可以是一个普通的字符串或是一个回调函数如果第一个参数是RegExp，JS会先提取RegExp匹配出的结果，然后用第二个参数逐一替换匹配出的结果。如果第二个参数是回调函数，每匹配到一个结果就回调一次]]></content>
      <categories>
        <category>正则入门</category>
      </categories>
      <tags>
        <tag>正则入门</tag>
      </tags>
  </entry>
</search>
